"""
Reporting module for generating PDF, Markdown, and summary reports.
"""
import io
from datetime import datetime
from typing import Dict, List, Any, Optional
import pandas as pd
import numpy as np

from app.core.config import CONFIG, get_class_color


def generate_prediction_report_md(
    filename: str,
    prediction: str,
    probabilities: Dict[str, float],
    features: Dict[str, float],
    hierarchical: Dict[str, Any] = None
) -> str:
    """Generate markdown report for a single prediction."""
    
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    report = f"""# EEG Classification Report

**Generated:** {timestamp}  
**Filename:** {filename}

---

## Prediction Summary

| Metric | Value |
|--------|-------|
| **Predicted Class** | {prediction} |
| **Confidence** | {max(probabilities.values()):.1%} |

### Class Probabilities

| Class | Probability |
|-------|-------------|
"""
    
    for cls, prob in probabilities.items():
        indicator = "⬅" if cls == prediction else ""
        report += f"| {cls} | {prob:.1%} {indicator} |\n"
    
    # Hierarchical diagnosis
    if hierarchical:
        report += f"""

### Hierarchical Diagnosis

**Stage 1 (Dementia vs Healthy):** {hierarchical.get('stage1_prediction', 'N/A')}  
- Dementia Probability: {hierarchical.get('dementia_probability', 0):.1%}

"""
        if hierarchical.get('stage2_prediction'):
            report += f"""**Stage 2 (AD vs FTD):** {hierarchical.get('stage2_prediction', 'N/A')}  
- AD Probability (given dementia): {hierarchical.get('ad_given_dementia', 0):.1%}
"""
    
    # Key features
    report += """

---

## Key Features

| Feature | Value | Clinical Meaning |
|---------|-------|-----------------|
"""
    
    key_features = [
        ('theta_alpha_ratio', 'Elevated in AD (>1.5)'),
        ('delta_alpha_ratio', 'Slowing marker (>1.0)'),
        ('peak_alpha_frequency', 'Slowed in AD (<9 Hz)'),
        ('spectral_entropy', 'Complexity measure'),
        ('theta_power', 'Theta band power'),
        ('alpha_power', 'Alpha band power'),
    ]
    
    for feat, meaning in key_features:
        if feat in features:
            report += f"| {feat} | {features[feat]:.4f} | {meaning} |\n"
    
    # Disclaimer
    report += """

---

## Disclaimer

⚠️ **IMPORTANT**: This report is for research and educational purposes only.

- Results should NOT be used for clinical diagnosis
- Always consult qualified healthcare professionals for medical decisions
- Model accuracy is limited (3-class: ~48%, binary: ~72%)
- Results may not generalize to new populations

---

*Generated by Alzheimer's EEG Classification Pipeline*
"""
    
    return report


def generate_batch_report_md(
    results_df: pd.DataFrame,
    features_df: pd.DataFrame = None
) -> str:
    """Generate markdown report for batch analysis."""
    
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    total = len(results_df)
    success = len(results_df[results_df['Status'] == 'Success'])
    failed = total - success
    
    report = f"""# Batch Analysis Report

**Generated:** {timestamp}  
**Files Processed:** {total}

---

## Summary Statistics

| Metric | Value |
|--------|-------|
| Total Files | {total} |
| Successful | {success} ({success/total*100:.1f}%) |
| Failed | {failed} |
"""
    
    if 'Processing_Time' in results_df.columns:
        avg_time = results_df['Processing_Time'].mean()
        report += f"| Avg. Processing Time | {avg_time:.2f}s |\n"
    
    # Prediction distribution
    if 'Prediction' in results_df.columns:
        success_df = results_df[results_df['Status'] == 'Success']
        pred_counts = success_df['Prediction'].value_counts()
        
        report += """

---

## Prediction Distribution

| Class | Count | Percentage |
|-------|-------|------------|
"""
        for pred, count in pred_counts.items():
            pct = count / success * 100 if success > 0 else 0
            report += f"| {pred} | {count} | {pct:.1f}% |\n"
    
    # Confidence statistics
    if 'Confidence' in results_df.columns:
        success_df = results_df[results_df['Status'] == 'Success']
        
        report += f"""

---

## Confidence Statistics

| Statistic | Value |
|-----------|-------|
| Mean Confidence | {success_df['Confidence'].mean():.1%} |
| Std Confidence | {success_df['Confidence'].std():.1%} |
| Min Confidence | {success_df['Confidence'].min():.1%} |
| Max Confidence | {success_df['Confidence'].max():.1%} |
"""
    
    # Individual results
    report += """

---

## Individual Results

| Filename | Prediction | Confidence | Status |
|----------|------------|------------|--------|
"""
    
    for _, row in results_df.iterrows():
        conf = f"{row['Confidence']:.1%}" if pd.notna(row.get('Confidence')) else "N/A"
        report += f"| {row['Filename']} | {row.get('Prediction', 'N/A')} | {conf} | {row['Status']} |\n"
    
    # Feature summary
    if features_df is not None and len(features_df) > 0:
        report += """

---

## Feature Summary

"""
        key_cols = ['delta_power', 'theta_power', 'alpha_power', 'beta_power', 
                   'theta_alpha_ratio', 'spectral_entropy']
        key_cols = [c for c in key_cols if c in features_df.columns]
        
        if key_cols:
            report += "| Feature | Mean | Std | Min | Max |\n"
            report += "|---------|------|-----|-----|-----|\n"
            
            for col in key_cols:
                stats = features_df[col].describe()
                report += f"| {col} | {stats['mean']:.4f} | {stats['std']:.4f} | {stats['min']:.4f} | {stats['max']:.4f} |\n"
    
    # Disclaimer
    report += """

---

## Disclaimer

⚠️ **IMPORTANT**: This report is for research and educational purposes only.

Results should NOT be used for clinical diagnosis.
Always consult qualified healthcare professionals for medical decisions.

---

*Generated by Alzheimer's EEG Classification Pipeline*
"""
    
    return report


def generate_dataset_report_md(
    participants_df: pd.DataFrame,
    stats: Dict[str, Any] = None
) -> str:
    """Generate markdown report for dataset overview."""
    
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    total = len(participants_df)
    
    report = f"""# Dataset Overview Report

**Generated:** {timestamp}  
**Dataset:** OpenNeuro ds004504

---

## Subject Summary

| Group | Count | Percentage |
|-------|-------|------------|
"""
    
    if 'Group' in participants_df.columns:
        group_counts = participants_df['Group'].value_counts()
        for group, count in group_counts.items():
            report += f"| {group} | {count} | {count/total*100:.1f}% |\n"
    
    report += f"| **Total** | **{total}** | **100%** |\n"
    
    # Demographics
    report += """

---

## Demographics

"""
    
    if 'Age' in participants_df.columns:
        age_stats = participants_df['Age'].describe()
        report += f"""### Age Distribution

| Statistic | Value |
|-----------|-------|
| Mean | {age_stats['mean']:.1f} years |
| Std | {age_stats['std']:.1f} years |
| Min | {age_stats['min']:.0f} years |
| Max | {age_stats['max']:.0f} years |

"""
    
    if 'Gender' in participants_df.columns:
        gender_counts = participants_df['Gender'].value_counts()
        report += """### Gender Distribution

| Gender | Count | Percentage |
|--------|-------|------------|
"""
        for gender, count in gender_counts.items():
            label = "Male" if gender == 'M' else "Female" if gender == 'F' else gender
            report += f"| {label} | {count} | {count/total*100:.1f}% |\n"
    
    if 'MMSE' in participants_df.columns:
        mmse_stats = participants_df['MMSE'].describe()
        report += f"""

### MMSE Scores

| Statistic | Value |
|-----------|-------|
| Mean | {mmse_stats['mean']:.1f} |
| Std | {mmse_stats['std']:.1f} |
| Min | {mmse_stats['min']:.0f} |
| Max | {mmse_stats['max']:.0f} |

**MMSE Interpretation:**
- 24-30: Normal cognition
- 18-23: Mild cognitive impairment
- <18: Moderate to severe impairment
"""
    
    # Recording details
    report += """

---

## Recording Details

| Parameter | Value |
|-----------|-------|
| Sampling Rate | 500 Hz |
| Channels | 19 (10-20 system) |
| Recording State | Eyes-closed resting |
| Format | EEGLAB (.set) |
| Preprocessing | Artifact-cleaned |

### EEG Channels

```
Fp1, Fp2 (Frontal pole)
F7, F3, Fz, F4, F8 (Frontal)
T3, C3, Cz, C4, T4 (Central/Temporal)
T5, P3, Pz, P4, T6 (Parietal/Temporal)
O1, O2 (Occipital)
```

---

## Data Source

**OpenNeuro Dataset:** ds004504

**Citation:**
Miltiadous, A., et al. (2023). A dataset of EEG recordings from 
Alzheimer's disease, Frontotemporal dementia and Healthy subjects. 
OpenNeuro. https://openneuro.org/datasets/ds004504

---

*Generated by Alzheimer's EEG Classification Pipeline*
"""
    
    return report


def try_generate_pdf(markdown_content: str) -> Optional[bytes]:
    """
    Attempt to generate PDF from markdown content.
    Returns None if PDF generation is not available.
    """
    try:
        # Try reportlab approach
        from reportlab.lib.pagesizes import letter
        from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
        from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
        from reportlab.lib.units import inch
        
        buffer = io.BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=letter)
        styles = getSampleStyleSheet()
        
        # Custom styles
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Heading1'],
            fontSize=18,
            spaceAfter=12
        )
        
        body_style = ParagraphStyle(
            'CustomBody',
            parent=styles['Normal'],
            fontSize=10,
            spaceAfter=6
        )
        
        story = []
        
        # Parse markdown and convert to PDF elements
        lines = markdown_content.split('\n')
        
        for line in lines:
            line = line.strip()
            if not line:
                story.append(Spacer(1, 0.1 * inch))
            elif line.startswith('# '):
                story.append(Paragraph(line[2:], title_style))
            elif line.startswith('## '):
                story.append(Paragraph(line[3:], styles['Heading2']))
            elif line.startswith('### '):
                story.append(Paragraph(line[4:], styles['Heading3']))
            elif line.startswith('**') and line.endswith('**'):
                story.append(Paragraph(f"<b>{line[2:-2]}</b>", body_style))
            elif line.startswith('|'):
                # Skip table formatting (complex to render)
                continue
            elif line.startswith('---'):
                story.append(Spacer(1, 0.2 * inch))
            elif line.startswith('- '):
                story.append(Paragraph(f"• {line[2:]}", body_style))
            elif line.startswith('⚠️') or line.startswith('✅'):
                story.append(Paragraph(line, body_style))
            else:
                story.append(Paragraph(line, body_style))
        
        doc.build(story)
        return buffer.getvalue()
        
    except ImportError:
        return None
    except Exception:
        return None


def create_zip_archive(files: Dict[str, bytes]) -> bytes:
    """Create a zip archive from a dictionary of files."""
    import zipfile
    
    buffer = io.BytesIO()
    
    with zipfile.ZipFile(buffer, 'w', zipfile.ZIP_DEFLATED) as zf:
        for filename, content in files.items():
            zf.writestr(filename, content)
    
    return buffer.getvalue()
